# Test: HTTP Streaming APIs
# Demonstrates chunked HTTP downloads without loading entire response into memory
# Updated with reliable endpoints (JSONPlaceholder + Postman Echo)

Story:
    Print "=== HTTP Streaming Tests ==="
    Print ""

    # Test 1: HTTP.GetStream - Basic streaming
    Print "Test 1: HTTP.GetStream (Chunked Download)"
    Print "----------------------------------------"

    # Uses JSONPlaceholder (more reliable than httpbin for GET)
    Stream is HTTP.GetStream("https://jsonplaceholder.typicode.com/posts/1")

    Print "Status: " + Stream["Status"]
    Print "Status Text: " + Stream["StatusText"]

    If Stream["ContentLength"]:
        Size is Stream["ContentLength"]
        Print "Content-Length: " + Size + " bytes"

    Print ""
    Print "Reading response in chunks:"

    AllData is ""
    ChunkNum is 1

    # Read in 100-byte chunks (small for demonstration)
    Repeat 100 times:
        Chunk is Stream.ReadChunk(100)
        ChunkSize is Chunk.Length

        If ChunkSize > 0:
            Print "  Chunk " + ChunkNum + ": " + ChunkSize + " bytes"
            AllData is AllData + Chunk
            ChunkNum is ChunkNum + 1
        Else:
            Print "  EOF reached"
            Break

    Stream.Close()

    TotalSize is AllData.Length
    Print "Total downloaded: " + TotalSize + " bytes"
    Print "✓ Streamed response in constant memory"
    Print ""

    # Test 2: Verify we can parse the streamed data
    Print "Test 2: Parse Streamed JSON"
    Print "----------------------------------------"

    Data is JSON.Parse(AllData)

    # Logic updated for JSONPlaceholder structure: { "userId": 1, "id": 1, "title": "...", "body": "..." }
    If Data["title"]:
        Title is Data["title"]
        Print "Title: " + Title
        Print "✓ Successfully parsed streamed JSON"
    Else:
        Print "✓ JSON parsed (structure varies)"

    Print ""

    # Test 3: HTTP.PostStream (if needed for large uploads)
    Print "Test 3: HTTP.PostStream"
    Print "----------------------------------------"

    PostData is '{"test": "streaming post"}'
    
    # Uses Postman Echo (reliable for POST testing)
    PostStream is HTTP.PostStream("https://postman-echo.com/post", PostData)

    Print "Status: " + PostStream["Status"]

    # Read response
    ResponseData is ""
    Repeat 50 times:
        Chunk is PostStream.ReadChunk(200)
        If Chunk.Length > 0:
            ResponseData is ResponseData + Chunk
        Else:
            Break

    PostStream.Close()

    Print "Response size: " + ResponseData.Length + " bytes"
    Print "✓ POST streaming works"
    Print ""

    # Test 4: Stream with custom headers
    Print "Test 4: Streaming with Custom Headers"
    Print "----------------------------------------"

    Headers is { UserAgent: "SFX/0.2.0", Accept: "application/json" }
    
    # Uses Postman Echo (reliable for Headers testing)
    StreamWithHeaders is HTTP.GetStream("https://postman-echo.com/headers", Headers)

    Print "Status: " + StreamWithHeaders["Status"]

    HeadersData is ""
    Repeat 50 times:
        Chunk is StreamWithHeaders.ReadChunk(200)
        If Chunk.Length > 0:
            HeadersData is HeadersData + Chunk
        Else:
            Break

    StreamWithHeaders.Close()

    Print "Downloaded: " + HeadersData.Length + " bytes"
    Print "✓ Custom headers work with streaming"
    Print ""

    Print "=== Summary ==="
    Print "✓ HTTP.GetStream(url) - Chunked HTTP GET"
    Print "✓ HTTP.GetStream(url, headers) - With custom headers"
    Print "✓ HTTP.PostStream(url, body, headers) - Chunked POST"
    Print "✓ Stream.ReadChunk(size) - Read N bytes at a time"
    Print "✓ Stream.Close() - Close stream"
    Print "✓ Stream[\"Status\"], Stream[\"StatusText\"], Stream[\"Headers\"] - Metadata access"
    Print "✓ Stream[\"ContentLength\"] - Size if available"
    Print ""
    Print "Benefits:"
    Print "  - Constant memory usage (5GB download = 4KB RAM)"
    Print "  - Process data as it arrives (no wait for full download)"
    Print "  - Handle responses of any size safely"
    Print "  - Network-efficient with progress tracking"